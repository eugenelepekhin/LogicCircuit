<#@ template language="C#" debug="True" inherits="Transformation" #>
<#@ import namespace="System.Reflection" #>
//-----------------------------------------------------------------------------
//
//	This code was generated by a <#=Assembly.GetEntryAssembly().GetName().Name#> Version <#=Assembly.GetEntryAssembly().GetName().Version.ToString()#>.
//
//	Changes to this file may cause incorrect behavior and will be lost if
//	the code is regenerated.
//
//-----------------------------------------------------------------------------

namespace <#=this.NameSpace#> {
	using System;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.CompilerServices;
	using System.ComponentModel;
	using System.Resources;
<#if(this.Pseudo) {#>
	using System.Collections.Generic;
	using System.Reflection;
<#}#>
<#if(this.FlowDirection) {#>
	using System.Windows;
<#}#>

	/// <summary>
	/// A strongly-typed resource class, for looking up localized strings, etc.
	/// </summary>
	// This class was auto-generated.
	// To add or remove a member, edit your .ResX file then rerun MsBuild,
	// or rebuild your VS project.
	[DebuggerNonUserCodeAttribute()]
	[CompilerGeneratedAttribute()]
	<#=this.IsPublic ? "public" : "internal"#> static class <#=this.ClassName#> {

		/// <summary>
		/// Overrides the current thread's CurrentUICulture property for all
		/// resource lookups using this strongly typed resource class.
		/// </summary>
		[EditorBrowsableAttribute(EditorBrowsableState.Advanced)]
		public static CultureInfo Culture { get; set; }

		/// <summary>
		/// Used for formating of the resource strings. Usually same as CultureInfo.CurrentCulture.
		/// </summary>
		[EditorBrowsableAttribute(EditorBrowsableState.Advanced)]
		public static CultureInfo FormatCulture { get; set; }

<#if(this.FlowDirection) {#>
<#	if(this.Pseudo) {#>
		private static bool isRightToLeft = ((Environment.TickCount / 500) & 1) == 0;
<#	}#>
		/// <summary>
		/// Gets FlowDirection for current culture.
		/// </summary>
		public static FlowDirection FlowDirection {
			get {
<#	if(!this.Pseudo) {#>
				bool isRightToLeft;
				if(<#=this.ClassName#>.Culture != null && <#=this.ClassName#>.Culture.TextInfo != null) {
					isRightToLeft = <#=this.ClassName#>.Culture.TextInfo.IsRightToLeft;
				} else if(CultureInfo.CurrentUICulture != null && CultureInfo.CurrentUICulture.TextInfo != null) {
					isRightToLeft = CultureInfo.CurrentUICulture.TextInfo.IsRightToLeft;
				} else if(CultureInfo.CurrentCulture != null && CultureInfo.CurrentCulture.TextInfo != null) {
					isRightToLeft = CultureInfo.CurrentCulture.TextInfo.IsRightToLeft;
				} else {
					isRightToLeft = false;
				}
<#	}#>
				return isRightToLeft ? FlowDirection.RightToLeft : FlowDirection.LeftToRight;
			}
		}
<#}#>

		private static <#=this.Pseudo ? "Pseudo" : ""#>ResourceManager resourceManager;

		/// <summary>
		/// Returns the cached ResourceManager instance used by this class.
		/// </summary>
		[EditorBrowsableAttribute(EditorBrowsableState.Advanced)]
		public static ResourceManager ResourceManager {
			get {
				if(resourceManager == null) {
					resourceManager = new <#=this.Pseudo ? "Pseudo" : ""#>ResourceManager("<#=this.ResourceName#>", typeof(<#=this.ClassName#>).Assembly);
				}
				return resourceManager;
			}
		}
<#if(this.Pseudo) {#>

		/// <summary>
		/// Performs pseudo localization of string resources
		/// </summary>
		private class PseudoResourceManager : ResourceManager {
			private static Dictionary<char, char> map = new Dictionary<char, char> {
				{ 'a', 'ä' },
				{ 'b', 'ƃ' },
				{ 'c', 'č' },
				{ 'd', 'ƌ' },
				{ 'e', 'ë' },
				{ 'f', 'ƒ' },
				{ 'g', 'ğ' },
				{ 'h', 'ħ' },
				{ 'i', 'ï' },
				{ 'j', 'ĵ' },
				{ 'k', 'ƙ' },
				{ 'l', 'ł' },
				{ 'm', 'ɱ' },
				{ 'n', 'ň' },
				{ 'o', 'ö' },
				{ 'p', 'þ' },
				{ 'q', 'ɋ' },
				{ 'r', 'ř' },
				{ 's', 'š' },
				{ 't', 'ŧ' },
				{ 'u', 'ü' },
				{ 'v', 'ṽ' },
				{ 'w', 'ŵ' },
				{ 'x', 'ӿ' },
				{ 'y', 'ŷ' },
				{ 'z', 'ž' },
				{ 'A', 'Ä' },
				{ 'B', 'Ɓ' },
				{ 'C', 'Č' },
				{ 'D', 'Đ' },
				{ 'E', 'Ë' },
				{ 'F', 'Ƒ' },
				{ 'G', 'Ğ' },
				{ 'H', 'Ħ' },
				{ 'I', 'Ï' },
				{ 'J', 'Ĵ' },
				{ 'K', 'Ҟ' },
				{ 'L', 'Ł' },
				{ 'M', 'Ӎ' },
				{ 'N', 'Ň' },
				{ 'O', 'Ö' },
				{ 'P', 'Ҏ' },
				{ 'Q', 'Ǫ' },
				{ 'R', 'Ř' },
				{ 'S', 'Š' },
				{ 'T', 'Ŧ' },
				{ 'U', 'Ü' },
				{ 'V', 'Ṽ' },
				{ 'W', 'Ŵ' },
				{ 'X', 'Ӿ' },
				{ 'Y', 'Ŷ' },
				{ 'Z', 'Ž' },
			};

			private Dictionary<string, string> resources = new Dictionary<string, string>();

			public PseudoResourceManager(string baseName, Assembly assembly) : base(baseName, assembly) {
			}

			public override string GetString(string name, CultureInfo culture) {
				if(culture == null) {
					return this.Pseudo(name);
				}
				return base.GetString(name, culture);
			}

			public string GetBaseString(string name, CultureInfo culture) {
				return base.GetString(name, culture);
			}

			public string GetBaseString(string[] values, string name, CultureInfo culture) {
				string text;
				if(!this.resources.TryGetValue(name, out text)) {
					Random random = new Random();
					this.resources[name] = text = values[random.Next(values.Length)];
					Debug.WriteLine("Pseudo Localizing {0} to value {1}", name, text);
				}
				return text;
			}

			private string Pseudo(string name) {
				string text;
				if(!this.resources.TryGetValue(name, out text)) {
					this.resources[name] = text = PseudoResourceManager.PseudoLocalize(base.GetString(name, null));
				}
				return text;
			}

			private static string PseudoLocalize(string text) {
				if(text == null) {
					text = string.Empty;
				}
				char[] result = new char[text.Length];
				bool open = false; // open means loop index i is inside of the format item. So no translations should happen as all the character are format specifiers.
				for(int i = 0; i < text.Length; i++) {
					char c = text[i];
					if(!open && c == '{') {
						if(i + 1 < text.Length && text[i + 1] == '{') {
							result[i++] = c;
						} else {
							open = i + 1 < text.Length && '0' <= text[i + 1] && text[i + 1] <= '9';
						}
					} else if(open && c == '}') {
						if(i + 1 < text.Length && text[i + 1] == '}') {
							result[i++] = c;
						} else {
							open = false;
						}
					}
					char pseudo;
					if(!open && map.TryGetValue(c, out pseudo)) {
						c = pseudo;
					}
					result[i] = c;
				}
				return "[-~=" + new string(result) + "=~-]";
			}
		}
<#}#>
<#foreach(ResourceItem item in this.Items) {#>

		/// <summary>
		/// Looks up a localized string similar to <#=item.Comment()#>.
		/// </summary>
<#	if(item.Parameters != null) {#>
 		public static string <#=item.Name#>(<#=item.ParametersDeclaration()#>) {
			return string.Format(FormatCulture, <#=item.GetStringExpression(this.Pseudo)#>"<#=item.Name#>", Culture), <#=item.ParametersInvocation()#>);
		}
<#	} else if(item.Type == "string") {#>
 		public static string <#=item.Name#> {
			get { return <#=item.GetStringExpression(this.Pseudo)#>"<#=item.Name#>", Culture); }
		}
<#	} else {#>
 		public static <#=item.Type#> <#=item.Name#> {
			get { return (<#=item.Type#>)ResourceManager.GetObject("<#=item.Name#>", Culture); }
		}
<#	}#>
<#}#>
	}
}
