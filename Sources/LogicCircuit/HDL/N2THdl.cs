// Ignore Spelling: Hdl

using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using static LogicCircuit.HdlConnection;

namespace LogicCircuit {
	internal class N2THdl : HdlTransformation {
		public N2THdl(string name, IEnumerable<HdlSymbol> inputPins, IEnumerable<HdlSymbol> outputPins, IEnumerable<HdlSymbol> parts) : base(name, inputPins, outputPins, parts) {
		}

		private static string PinsText(IEnumerable<HdlSymbol> pins) {
			StringBuilder text = new StringBuilder();
			bool comma = false;
			foreach(HdlSymbol symbol in pins) {
				if(comma) {
					text.Append(", ");
				} else {
					comma = true;
				}
				Pin pin = (Pin)symbol.CircuitSymbol.Circuit;
				text.Append(pin.Name);
				if(1 < pin.BitWidth) {
					text.AppendFormat(CultureInfo.InvariantCulture, "[{0}]", pin.BitWidth);
				}
			}
			return text.ToString();
		}

		private static string SymbolJamName(HdlSymbol symbol, HdlConnection connection) {
			Debug.Assert(symbol == connection.OutHdlSymbol || symbol == connection.InHdlSymbol);
			Debug.Assert(symbol.CircuitSymbol.Circuit is not Pin);
			Jam jam = connection.SymbolJam(symbol);
			string name = symbol.HdlExport.HdlName(jam);
			if(connection.IsBitRange(symbol)) {
				BitRange bits = (jam == connection.OutJam) ? connection.OutBits : connection.InBits;
				name += bits.ToString();
			}
			return name;
		}

		public static string PinName(HdlSymbol symbol, HdlConnection connection) {
			Debug.Assert(symbol == connection.OutHdlSymbol || symbol == connection.InHdlSymbol);
			HdlSymbol otherSymbol;
			Jam otherJam;
			BitRange otherBits;
			if(symbol == connection.OutHdlSymbol) {
				otherSymbol = connection.InHdlSymbol;
				otherJam = connection.InJam;
				otherBits = connection.InBits;
			} else {
				otherSymbol = connection.OutHdlSymbol;
				otherJam = connection.OutJam;
				otherBits = connection.OutBits;
			}
			if(otherJam.CircuitSymbol.Circuit is Pin pin) {
				string name = pin.Name;
				if(connection.IsBitRange(otherSymbol)) {
					name += otherBits.ToString();
				}
				return name;
			}
			if(otherJam.CircuitSymbol.Circuit is Constant constant) {
				Debug.Assert(otherBits.First == otherBits.Last);
				int value = (constant.ConstantValue >> otherBits.First) & 1;
				return (value == 0) ? "false" : "true";
			}
			GridPoint point = connection.OutJam.AbsolutePoint;
			string pinName = string.Format(CultureInfo.InvariantCulture, "Pin{0}x{1}", point.X, point.Y);
			if(connection.IsBitRange(connection.OutHdlSymbol)) {
				BitRange outBits = connection.OutBits;
				if(outBits.First == outBits.Last) {
					pinName += string.Format(CultureInfo.InvariantCulture, "b{0}", outBits.First);
				} else {
					pinName += string.Format(CultureInfo.InvariantCulture, "s{0}e{1}", outBits.First, outBits.Last);
				}
			}
			if(0 < connection.OutHdlSymbol.Subindex) {
				pinName += string.Format(CultureInfo.InvariantCulture, "v{0}", connection.OutHdlSymbol.Subindex);
			}
			return pinName;
		}

		public override string TransformText() {
			this.WriteLine("CHIP {0} {{", this.Name);
			if(this.HasInputPins) {
				this.WriteLine("IN {0};", N2THdl.PinsText(this.InputPins));
			}
			if(this.HasOutputPins) {
				this.WriteLine("OUT {0};", N2THdl.PinsText(this.OutputPins));
			}
			this.WriteLine("PARTS:");
			foreach(HdlSymbol symbol in this.Parts) {
				bool comma = false;
				if(this.CommentPoints && (!symbol.AutoGenerated || symbol.Subindex == 1)) {
					this.WriteLine("\t// {0}", symbol.Comment);
				}
				this.Write("\t{0}(", symbol.HdlExport.HdlName(symbol));
				foreach(HdlConnection connection in symbol.HdlConnections().Where(c => c.GenerateOutput(symbol))) {
					if(comma) {
						this.Write(", ");
					}
					comma = true;
					this.Write("{0}={1}", N2THdl.SymbolJamName(symbol, connection), N2THdl.PinName(symbol, connection));
				}
				this.WriteLine(");");
			}
			this.WriteLine("}");
            return this.GenerationEnvironment.ToString();
		}
	}
}
