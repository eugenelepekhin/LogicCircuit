// Ignore Spelling: Hdl

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace LogicCircuit {
	internal class HdlSymbol {
		private readonly struct JamKey : IEquatable<JamKey> {
			public readonly Jam OutJam;
			public readonly Jam InJam;

			public JamKey(Jam outJam, Jam inJam) {
				this.OutJam = outJam;
				this.InJam = inJam;
			}

			public bool Equals(JamKey other) => this.OutJam == other.OutJam && this.InJam == other.InJam;
			public override bool Equals(object? obj) => obj is JamKey && this.Equals((JamKey)obj);
			public override int GetHashCode() => HashCode.Combine(this.OutJam, this.InJam);

			#if DEBUG
				public override string ToString() => $"{this.OutJam}->{this.InJam}";
			#endif
		}

		private readonly struct JamRange : IEquatable<JamRange> {
			public readonly Jam Jam;
			public readonly HdlConnection.BitRange Range;

			public JamRange(Jam jam, HdlConnection.BitRange range) {
				this.Jam = jam;
				this.Range = range;
			}

			public bool Equals(JamRange other) => this.Jam == other.Jam && this.Range == other.Range;
			public override bool Equals(object? obj) => obj is JamRange other && this.Equals(other);
			public override int GetHashCode() => HashCode.Combine(this.Jam, this.Range);

			#if DEBUG
				public override string ToString() => $"{this.Jam}{this.Range}";
			#endif
		}

		public HdlExport HdlExport { get; }
		public CircuitSymbol CircuitSymbol { get; }
		
		private readonly OneToMany<JamKey, HdlConnection> connections = new OneToMany<JamKey, HdlConnection>();
		private List<HdlConnection>? connectionList;

		public int Order { get; set; }
		public int Subindex { get; set; }
		public bool AutoGenerated { get; set; }

		private string? comment;
		public string Comment {
			get => this.comment ?? string.Format(CultureInfo.InvariantCulture, "{0}{1}", this.CircuitSymbol.Circuit.Name, this.CircuitSymbol.Point);
			set => this.comment = value;
		}

		public HdlSymbol(HdlExport export, CircuitSymbol symbol) {
			this.HdlExport = export;
			this.CircuitSymbol = symbol;
		}

		public void Add(HdlConnection connection) {
			Debug.Assert(this.connectionList == null);
			this.connections.Add(new JamKey(connection.OutJam, connection.InJam), connection);
		}

		public void Replace(HdlConnection connection, HdlConnection replacement) {
			Debug.Assert(this.connectionList != null);
			int index = this.connectionList.IndexOf(connection);
			Debug.Assert(0 <= index);
			this.connectionList.RemoveAt(index);
			this.connectionList.Insert(index, replacement);
		}

		public IEnumerable<HdlConnection> Find(Jam outJam, Jam inJam) {
			Debug.Assert(this.connectionList == null);
			if(this.connections.TryGetValue(new JamKey(outJam, inJam), out IList<HdlConnection>? list)) {
				return list;
			}
			return Enumerable.Empty<HdlConnection>();
		}

		public IEnumerable<HdlConnection> HdlConnections() {
			if(this.connectionList == null) {
				return this.connections.Values.SelectMany(connections => connections);
			}
			return this.connectionList;
		}

		public void SortConnections() {
			int compare(HdlConnection x, HdlConnection y) {
				
				if(x.SymbolJam(this).Pin.PinType == PinType.Input && y.SymbolJam(this).Pin.PinType != PinType.Input) {
					return -1;
				}
				if(x.SymbolJam(this).Pin.PinType != PinType.Input && y.SymbolJam(this).Pin.PinType == PinType.Input) {
					return 1;
				}
				return StringComparer.Ordinal.Compare(x.SymbolJam(this).Pin.Name, y.SymbolJam(this).Pin.Name);
			}

			Debug.Assert(this.connectionList == null);
			this.connectionList = this.HdlConnections().ToList();
			this.connectionList.Sort(compare);

			OneToMany<JamRange, HdlConnection> byRange = new OneToMany<JamRange, HdlConnection>();
			foreach(HdlConnection connection in this.connectionList.Where(c => this == c.OutHdlSymbol)) {
				JamRange jamRange = new JamRange(connection.OutJam, connection.OutBits);
				byRange.Add(jamRange, connection);
			}
			foreach(IList<HdlConnection> list in byRange.Values) {
				if(1 < list.Count) {
					bool skip = false;
					for(int i = 0; i < list.Count; i++) {
						if(list[i].InHdlSymbol.CircuitSymbol.Circuit is not Pin) {
							list[i].SkipOutput = skip;
							skip = true;
						}
					}
				}
			}
		}

		#if DEBUG
			public override string ToString() => $"HdlSymbol of {this.CircuitSymbol.ToString()}";
		#endif
	}
}
